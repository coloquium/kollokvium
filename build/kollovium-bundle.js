/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./client/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./client/AppDomain.js":
/*!*****************************!*\
  !*** ./client/AppDomain.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n *  Class enebales customization of \"Kollokvium\" for personal / corperate usage\n *\n * @export\n * @class AppDomain\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst appConfig = __webpack_require__(/*! ./settings.json */ \"./client/settings.json\");\nclass AppDomain {\n    getSlug(value) {\n        return `${this.contextPrefix}-${value}`;\n    }\n    constructor() {\n        this.domain = appConfig.domain;\n        this.contextPrefix = appConfig.contextPrefix;\n        this.serverUrl = appConfig.serverUrl;\n        this.version = appConfig.version;\n    }\n}\nexports.AppDomain = AppDomain;\n\n\n//# sourceURL=webpack:///./client/AppDomain.js?");

/***/ }),

/***/ "./client/AppParticipant.js":
/*!**********************************!*\
  !*** ./client/AppParticipant.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass AppParticipant {\n    constructor(id) {\n        this.id = id;\n        this.videoTracks = new Array();\n        this.audioTracks = new Array();\n    }\n    addVideoTrack(t) {\n        this.videoTracks.push(t);\n        let stream = new MediaStream([t]);\n        t.onended = () => {\n            // todo: would be an delagated event\n            this.onVideoTrackLost(this.id, stream, t);\n        };\n        this.onVideoTrackAdded(this.id, stream, t);\n    }\n    addAudioTrack(t) {\n        this.audioTracks.push(t);\n        let audio = new Audio();\n        audio.classList.add(\".p\" + this.id);\n        audio.autoplay = true;\n        audio.srcObject = new MediaStream([t]);\n        return audio;\n    }\n    addTrack(t, cb) {\n        if (t.kind == \"video\") {\n            this.addVideoTrack(t);\n        }\n        else {\n            let a = this.addAudioTrack(t);\n            if (cb)\n                cb(a);\n        }\n        //t.kind == \"video\" ? this.addVideoTrack(t) : this.addAudioTrack(t);\n    }\n}\nexports.AppParticipant = AppParticipant;\n\n\n//# sourceURL=webpack:///./client/AppParticipant.js?");

/***/ }),

/***/ "./client/ReadFile.js":
/*!****************************!*\
  !*** ./client/ReadFile.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass ReadFile {\n    static read(f) {\n        return new Promise((resolve, reject) => {\n            let reader = new FileReader();\n            reader.onerror = reject;\n            reader.onload = (function (tf) {\n                return function (e) {\n                    resolve({ buffer: e.target.result, tf: tf });\n                };\n            })(f);\n            reader.readAsArrayBuffer(f);\n        });\n    }\n}\nexports.ReadFile = ReadFile;\n\n\n//# sourceURL=webpack:///./client/ReadFile.js?");

/***/ }),

/***/ "./client/Recorder/MediaStreamRecorder.js":
/*!************************************************!*\
  !*** ./client/Recorder/MediaStreamRecorder.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass MediaStreamRecorder {\n    constructor(tracks) {\n        this.tracks = tracks;\n        this.mediaStream = new MediaStream(tracks);\n        this.recorder = new MediaRecorder(this.mediaStream, {\n            mimeType: 'video/webm;codecs=vp9'\n        });\n        this.recorder.ondataavailable = (e) => {\n            if (e.data.size > 0)\n                this.data.push(e.data);\n        };\n    }\n    toBlob() {\n        let blob = new Blob(this.data, {\n            type: 'video/webm'\n        });\n        return URL.createObjectURL(blob);\n    }\n    flush(r) {\n        return new Promise((resolve, reject) => {\n            r == resolve(this.toBlob());\n            this.data = new Array();\n        });\n    }\n    stop() {\n        this.recorder.stop();\n    }\n    start(n) {\n        this.data = new Array();\n        this.recorder.start(n);\n    }\n}\nexports.MediaStreamRecorder = MediaStreamRecorder;\n\n\n//# sourceURL=webpack:///./client/Recorder/MediaStreamRecorder.js?");

/***/ }),

/***/ "./client/SlugHistory.js":
/*!*******************************!*\
  !*** ./client/SlugHistory.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass SlugHistory {\n    constructor() {\n    }\n    getHistory() {\n        return this.history;\n    }\n    addToHistory(slug) {\n        if (this.history.includes(slug))\n            return;\n        this.history.push(slug);\n    }\n    clearHistory() {\n        this.history = new Array();\n    }\n}\nexports.SlugHistory = SlugHistory;\n\n\n//# sourceURL=webpack:///./client/SlugHistory.js?");

/***/ }),

/***/ "./client/UserSettings.js":
/*!********************************!*\
  !*** ./client/UserSettings.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SlugHistory_1 = __webpack_require__(/*! ./SlugHistory */ \"./client/SlugHistory.js\");\nclass UserSettings {\n    saveSetting() {\n        const data = {\n            slugHistory: this.slugHistory.history,\n            videoDevice: this.videoDevice,\n            audioDevice: this.audioDevice,\n            nickname: this.nickname\n        };\n        localStorage.setItem(\"settings\", JSON.stringify(data));\n    }\n    createConstraints() {\n        const constraints = {\n            video: {\n                width: { min: 640, ideal: 1280 },\n                height: { min: 400, ideal: 720 }\n            }, audio: true,\n        };\n        if (this.audioDevice.length > 0) {\n            constraints.video[\"deviceId\"] = this.audioDevice;\n        }\n        if (this.videoDevice.length > 0) {\n            constraints.video[\"deviceId\"] = this.videoDevice;\n        }\n        return constraints;\n    }\n    constructor() {\n        this.slugHistory = new SlugHistory_1.SlugHistory();\n        const ls = localStorage.getItem(\"settings\");\n        if (ls) {\n            let settings = JSON.parse(ls);\n            this.audioDevice = settings.audioDevice;\n            this.videoDevice = settings.videoDevice;\n            this.nickname = settings.nickname;\n            this.slugHistory.history = settings.slugHistory;\n        }\n        else {\n            this.slugHistory.history = new Array();\n            this.nickname = Math.random().toString(36).substring(8);\n            this.audioDevice = \"\";\n            this.videoDevice = \"\";\n        }\n    }\n}\nexports.UserSettings = UserSettings;\n\n\n//# sourceURL=webpack:///./client/UserSettings.js?");

/***/ }),

/***/ "./client/app.js":
/*!***********************!*\
  !*** ./client/app.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst thor_io_client_vnext_1 = __webpack_require__(/*! thor-io.client-vnext */ \"./node_modules/thor-io.client-vnext/index.js\");\nconst clipboard_1 = __importDefault(__webpack_require__(/*! clipboard */ \"./node_modules/clipboard/dist/clipboard.js\"));\nconst AppParticipant_1 = __webpack_require__(/*! ./AppParticipant */ \"./client/AppParticipant.js\");\nconst ReadFile_1 = __webpack_require__(/*! ./ReadFile */ \"./client/ReadFile.js\");\nconst UserSettings_1 = __webpack_require__(/*! ./UserSettings */ \"./client/UserSettings.js\");\nconst AppDomain_1 = __webpack_require__(/*! ./AppDomain */ \"./client/AppDomain.js\");\nconst MediaStreamRecorder_1 = __webpack_require__(/*! ./Recorder/MediaStreamRecorder */ \"./client/Recorder/MediaStreamRecorder.js\");\nclass App {\n    /**\n     * Creates an instance of App - Kollokvium\n     * @memberof App\n     */\n    constructor() {\n        /**\n         * PeerConnection configuration\n         *\n         * @memberof App\n         */\n        this.rtcConfig = {\n            \"sdpSemantics\": 'plan-b',\n            \"iceTransports\": 'all',\n            \"rtcpMuxPolicy\": \"require\",\n            \"bundlePolicy\": \"max-bundle\",\n            \"iceServers\": [\n                {\n                    \"urls\": \"stun:stun.l.google.com:19302\"\n                }\n            ]\n        };\n        // see settings.json\n        this.appDomain = new AppDomain_1.AppDomain();\n        document.querySelector(\"#appDomain\").textContent = this.appDomain.domain;\n        document.querySelector(\"#appVersion\").textContent = this.appDomain.version;\n        this.userSettings = new UserSettings_1.UserSettings();\n        // Remove screenshare on tables / mobile hack..\n        if (typeof window.orientation !== 'undefined') {\n            document.querySelector(\".only-desktop\").classList.add(\"hide\");\n        }\n        if (!location.href.includes(\"https://\"))\n            this.peerId = null;\n        this.numOfChatMessagesUnread = 0;\n        this.participants = new Map();\n        this.Slug = location.hash.replace(\"#\", \"\");\n        this.fullScreenVideo = document.querySelector(\".full\");\n        this.shareContainer = document.querySelector(\"#share-container\");\n        this.shareFile = document.querySelector(\"#share-file\");\n        this.videoGrid = document.querySelector(\"#video-grid\");\n        let slug = document.querySelector(\"#slug\");\n        let startButton = document.querySelector(\"#joinconference\");\n        let chatWindow = document.querySelector(\".chat\");\n        let chatMessage = document.querySelector(\"#chat-message\");\n        let chatNick = document.querySelector(\"#chat-nick\");\n        let chatMessages = document.querySelector(\"#chatmessages\");\n        let muteAudio = document.querySelector(\"#mute-local-audio\");\n        let muteVideo = document.querySelector(\"#mute-local-video\");\n        let startScreenShare = document.querySelector(\"#share-screen\");\n        let settings = document.querySelector(\"#settings\");\n        let saveSettings = document.querySelector(\"#save-settings\");\n        let unreadBadge = document.querySelector(\"#unread-messages\");\n        let generateSlug = document.querySelector(\"#generate-slug\");\n        let nickname = document.querySelector(\"#txt-nick\");\n        let videoDevice = document.querySelector(\"#sel-video\");\n        let audioDevice = document.querySelector(\"#sel-audio\");\n        nickname.value = this.userSettings.nickname;\n        this.getMediaDevices().then((devices) => {\n            let inputOnly = devices.filter(((d) => {\n                return d.kind.indexOf(\"input\") > 0;\n            }));\n            inputOnly.forEach((d) => {\n                let option = document.createElement(\"option\");\n                option.textContent = d.label;\n                option.setAttribute(\"value\", d.deviceId);\n                if (d.kind == \"videoinput\") {\n                    document.querySelector(\"#sel-video\").append(option);\n                }\n                else {\n                    document.querySelector(\"#sel-audio\").append(option);\n                }\n            });\n            videoDevice.value = this.userSettings.videoDevice;\n            audioDevice.value = this.userSettings.audioDevice;\n            // get the media devices \n        }).catch(console.error);\n        saveSettings.addEventListener(\"click\", () => {\n            this.userSettings.nickname = nickname.value;\n            this.userSettings.audioDevice = audioDevice.value;\n            this.userSettings.videoDevice = videoDevice.value;\n            this.userSettings.saveSetting();\n            this.rtcClient.LocalStreams.forEach((m) => {\n                document.querySelector(\".l-\" + m.id).remove();\n            });\n            this.rtcClient.LocalStreams = new Array();\n            this.getLocalStream(this.userSettings.createConstraints(), (mediaStream) => {\n                this.localMediaStream = mediaStream;\n                this.rtcClient.AddLocalStream(mediaStream);\n                this.addLocalVideo(mediaStream);\n            });\n        });\n        settings.addEventListener(\"click\", () => {\n            $(\"#settings-modal\").modal(\"toggle\");\n        });\n        // jQuery hack for file share\n        $(\"#share-file\").popover({\n            trigger: \"manual\",\n            sanitize: false,\n            placement: \"top\",\n            title: 'Select the file to share.',\n            html: true,\n            content: $('#share-form').html()\n        }).on(\"inserted.bs.popover\", (e) => {\n            $(\".file-selected\").on(\"change\", (evt) => {\n                const file = evt.target.files[0];\n                ReadFile_1.ReadFile.read(file).then((result) => {\n                    this.sendFile({\n                        name: result.tf.name,\n                        size: result.tf.size,\n                        mimeType: result.tf.type\n                    }, result.buffer);\n                    $(\"#share-file\").popover(\"hide\");\n                });\n            });\n        });\n        this.userSettings.slugHistory.getHistory().forEach((slug) => {\n            const option = document.createElement(\"option\");\n            option.setAttribute(\"value\", slug);\n            document.querySelector(\"#slug-history\").prepend(option);\n        });\n        generateSlug.addEventListener(\"click\", () => {\n            slug.value = Math.random().toString(36).substring(2).toLocaleLowerCase();\n            startButton.disabled = false;\n            $(\"#random-slug\").popover(\"hide\");\n        });\n        muteAudio.addEventListener(\"click\", (e) => {\n            this.muteAudio(e);\n        });\n        muteVideo.addEventListener(\"click\", (e) => {\n            this.muteVideo(e);\n        });\n        startScreenShare.addEventListener(\"click\", () => {\n            this.shareScreen();\n        });\n        this.shareFile.addEventListener(\"click\", () => {\n            $(\"#share-file\").popover(\"toggle\");\n        });\n        let clipBoard = new clipboard_1.default(\"#share-link\", {\n            text: (t) => {\n                t.textContent = \"Done!\";\n                return location.origin + \"/#\" + slug.value;\n            }\n        });\n        if (this.Slug.length >= 6) {\n            slug.value = this.Slug;\n            startButton.disabled = false;\n            document.querySelector(\"#random-slug\").classList.add(\"d-none\"); // if slug predefined, no random option...\n        }\n        document.querySelector(\"#close-chat\").addEventListener(\"click\", () => {\n            chatWindow.classList.toggle(\"d-none\");\n            unreadBadge.classList.add(\"d-none\");\n            this.numOfChatMessagesUnread = 0;\n            unreadBadge.textContent = \"0\";\n        });\n        document.querySelector(\"#show-chat\").addEventListener(\"click\", () => {\n            chatWindow.classList.toggle(\"d-none\");\n            unreadBadge.classList.add(\"d-none\");\n            this.numOfChatMessagesUnread = 0;\n            unreadBadge.textContent = \"0\";\n        });\n        slug.addEventListener(\"click\", () => {\n            $(\"#slug\").popover('show');\n            $(\"#random-slug\").popover(\"hide\");\n        });\n        if (location.hash.length == 0) {\n            $(\"#random-slug\").popover(\"show\");\n        }\n        else {\n            startButton.textContent = \"JOIN\";\n        }\n        slug.addEventListener(\"keyup\", () => {\n            if (slug.value.length >= 6) {\n                startButton.disabled = false;\n            }\n            else {\n                startButton.disabled = true;\n            }\n        });\n        chatNick.value = this.userSettings.nickname;\n        chatNick.addEventListener(\"click\", () => {\n            chatNick.value = \"\";\n        });\n        startButton.addEventListener(\"click\", () => {\n            this.videoGrid.classList.add(\"d-flex\");\n            $(\"#random-slug\").popover(\"hide\");\n            document.querySelector(\"#share-file\").classList.toggle(\"hide\");\n            document.querySelector(\"#share-screen\").classList.toggle(\"d-none\");\n            document.querySelector(\"#show-chat\").classList.toggle(\"d-none\");\n            document.querySelector(\".our-brand\").remove();\n            $(\"#slug\").popover('hide');\n            startButton.classList.add(\"hide\");\n            document.querySelector(\".remote\").classList.remove(\"hide\");\n            document.querySelector(\".overlay\").classList.add(\"d-none\");\n            document.querySelector(\".join\").classList.add(\"d-none\");\n            this.userSettings.slugHistory.addToHistory(slug.value);\n            this.userSettings.saveSetting();\n            this.rtcClient.ChangeContext(this.appDomain.getSlug(slug.value));\n        });\n        // if local ws://localhost:1337/     \n        //  wss://simpleconf.herokuapp.com/\n        this.factory = this.connectToServer(this.appDomain.serverUrl, {});\n        this.factory.OnClose = (reason) => {\n            console.error(reason);\n        };\n        this.factory.OnOpen = (broker) => {\n            this.rtcClient = new thor_io_client_vnext_1.WebRTC(broker, this.rtcConfig);\n            broker.On(\"fileShare\", (fileinfo, arrayBuffer) => {\n                this.fileReceived(fileinfo, arrayBuffer);\n            });\n            // hook up chat functions...\n            broker.On(\"instantMessage\", (im) => {\n                this.numOfChatMessagesUnread++;\n                let message = document.createElement(\"p\");\n                message.textContent = im.text;\n                let sender = document.createElement(\"mark\");\n                sender.textContent = im.from;\n                message.prepend(sender);\n                chatMessages.prepend(message);\n                if (chatWindow.classList.contains(\"d-none\")) {\n                    unreadBadge.classList.remove(\"d-none\");\n                    unreadBadge.textContent = this.numOfChatMessagesUnread.toString();\n                }\n            });\n            chatMessage.addEventListener(\"keyup\", (e) => {\n                if (e.keyCode == 13) {\n                    this.sendMessage(chatNick.value, chatMessage.value);\n                    chatMessage.value = \"\";\n                }\n            });\n            this.rtcClient.OnLocalStream = (mediaStream) => {\n            };\n            this.rtcClient.OnContextConnected = (ctx) => {\n            };\n            this.rtcClient.OnContextCreated = (ctx) => {\n            };\n            this.rtcClient.OnContextChanged = (ctx) => {\n                this.rtcClient.ConnectContext();\n            };\n            this.rtcClient.OnContextDisconnected = (peer) => {\n                document.querySelector(\".p\" + peer.id).remove();\n            };\n            this.rtcClient.OnContextConnected = (peer) => {\n                document.querySelector(\".remote\").classList.remove(\"hide\");\n                // addRemoteVideo(peer.stream, peer.id);\n            };\n            this.rtcClient.OnRemoteTrack = (track, connection) => {\n                let participant = this.tryAddParticipant(connection.id);\n                participant.addTrack(track, (el) => {\n                    document.querySelector(\"#remtote-audio-nodes\").append(el);\n                });\n                participant.onVideoTrackLost = (id, stream, track) => {\n                    let p = document.querySelector(\".p\" + id);\n                    if (p)\n                        p.remove();\n                };\n            };\n            this.rtcClient.OnContextCreated = function (ctx) {\n                // noop\n            };\n            broker.OnOpen = (ci) => {\n                this.getLocalStream(this.userSettings.createConstraints(), (mediaStream) => {\n                    this.localMediaStream = mediaStream;\n                    this.rtcClient.AddLocalStream(mediaStream);\n                    this.addLocalVideo(mediaStream);\n                });\n            };\n            broker.Connect();\n        };\n    }\n    // Create a an AppDomain of kollokvium;\n    getLocalStream(constraints, cb) {\n        navigator.mediaDevices.getUserMedia(constraints).then((mediaStream) => {\n            cb(mediaStream);\n        }).catch(err => {\n            console.error(err);\n        });\n    }\n    /**\n     * Adds a fileshare message to chat, when someone shared a file...\n     *\n     * @param {*} fileinfo\n     * @param {ArrayBuffer} arrayBuffer\n     * @memberof App\n     */\n    fileReceived(fileinfo, arrayBuffer) {\n        const p = document.createElement(\"p\");\n        p.textContent = \"Hye,here is shared file... \";\n        const blob = new Blob([arrayBuffer], {\n            type: fileinfo.mimeType\n        });\n        const blobUrl = window.URL.createObjectURL(blob);\n        const download = document.createElement(\"a\");\n        download.setAttribute(\"href\", blobUrl);\n        download.textContent = fileinfo.name;\n        download.setAttribute(\"download\", fileinfo.name);\n        p.append(download);\n        document.querySelector(\"#chatmessages\").prepend(p);\n    }\n    /**\n     * Send a file to all in conference\n     *\n     * @param {*} fileInfo\n     * @param {ArrayBuffer} buffer\n     * @memberof App\n     */\n    sendFile(fileInfo, buffer) {\n        var message = new thor_io_client_vnext_1.Message(\"fileShare\", fileInfo, \"broker\", buffer);\n        let bm = new thor_io_client_vnext_1.BinaryMessage(message.toString(), buffer);\n        this.factory.GetController(\"broker\").InvokeBinary(bm.Buffer);\n    }\n    /**\n     * Prompt user for a screen , tab, window.\n     * and add the media stream to share\n     * @memberof App\n     */\n    shareScreen() {\n        const gdmOptions = {\n            video: {\n                cursor: \"always\"\n            },\n            audio: false\n        };\n        navigator.mediaDevices[\"getDisplayMedia\"](gdmOptions).then((stream) => {\n            stream.getVideoTracks().forEach((t) => {\n                this.rtcClient.LocalStreams[0].addTrack(t);\n            });\n            this.addLocalVideo(stream);\n            document.querySelector(\"#share-screen\").classList.add(\"hide\");\n        }).catch(err => console.error);\n    }\n    /**\n     * Mute local video  ( self )\n     *\n     * @param {*} evt\n     * @memberof App\n     */\n    muteVideo(evt) {\n        let el = evt.target;\n        el.classList.toggle(\"fa-video\");\n        el.classList.toggle(\"fa-video-slash\");\n        let mediaTrack = this.localMediaStream.getVideoTracks();\n        mediaTrack.forEach((track) => {\n            track.enabled = !track.enabled;\n        });\n    }\n    /**\n     * Mute local video ( self )\n     *\n     * @param {*} evt\n     * @memberof App\n     */\n    muteAudio(evt) {\n        let el = evt.target;\n        el.classList.toggle(\"fa-microphone\");\n        el.classList.toggle(\"fa-microphone-slash\");\n        let mediaTrack = this.localMediaStream.getAudioTracks();\n        mediaTrack.forEach((track) => {\n            track.enabled = !track.enabled;\n        });\n    }\n    /**\n     * Record a remotestream\n     *\n     * @param {string} peerid\n     * @memberof App\n     */\n    recordStream(peerid) {\n        if (!this.recorder) {\n            let tracks = this.rtcClient.Peers.get(peerid).stream.getTracks();\n            this.recorder = new MediaStreamRecorder_1.MediaStreamRecorder(tracks);\n            this.recorder.mediaStream.addTrack(this.rtcClient.LocalStreams[0].getAudioTracks()[0]);\n            this.recorder.start(20);\n        }\n        else {\n            this.recorder.stop();\n            let result = this.recorder.toBlob();\n            const download = document.createElement(\"a\");\n            download.setAttribute(\"href\", result);\n            download.textContent = peerid;\n            download.setAttribute(\"download\", `${peerid}.webm`);\n            document.querySelector(\"#recorder-download\").append(download);\n            $(\"#recorder-result\").modal(\"show\");\n            this.recorder = null;\n        }\n    }\n    /**\n     * Add a local media stream to the UI\n     *\n     * @param {MediaStream} mediaStream\n     * @memberof App\n     */\n    addLocalVideo(mediaStream) {\n        let video = document.createElement(\"video\");\n        video.autoplay = true;\n        video.muted = true;\n        video.classList.add(\"l-\" + mediaStream.id);\n        video.srcObject = mediaStream;\n        let container = document.querySelector(\".local\");\n        container.append(video);\n    }\n    /**\n     * Send chat message\n     *\n     * @param {string} sender\n     * @param {string} message\n     * @memberof App\n     */\n    sendMessage(sender, message) {\n        if (sender.length == 0)\n            sender = \"NoName\";\n        const data = {\n            text: message,\n            from: sender\n        };\n        this.factory.GetController(\"broker\").Invoke(\"instantMessage\", data);\n    }\n    /**\n     *  Connect to the realtime server (websocket) and its controller\n     *\n     * @param {string} url\n     * @param {*} config\n     * @returns {Factory}\n     * @memberof App\n     */\n    connectToServer(url, config) {\n        return new thor_io_client_vnext_1.Factory(url, [\"broker\"]);\n    }\n    /**\n     * Add remote video stream\n     *\n     * @param {string} id\n     * @param {MediaStream} mediaStream\n     * @memberof App\n     */\n    addRemoteVideo(id, mediaStream) {\n        if (!this.shareContainer.classList.contains(\"hide\")) {\n            this.shareContainer.classList.add(\"hide\");\n        }\n        let videoTools = document.createElement(\"div\");\n        videoTools.classList.add(\"video-tools\");\n        let item = document.createElement(\"li\");\n        item.setAttribute(\"class\", \"p\" + id);\n        let f = document.createElement(\"i\");\n        f.classList.add(\"fas\", \"fa-arrows-alt\", \"fa-2x\", \"fullscreen\");\n        let r = document.createElement(\"i\");\n        r.classList.add(\"fas\", \"fa-circle\", \"fa-2x\", \"record\");\n        r.dataset.peerid = id;\n        videoTools.append(f);\n        videoTools.append(r);\n        item.prepend(videoTools);\n        let video = document.createElement(\"video\");\n        video.srcObject = mediaStream;\n        video.width = 1920;\n        video.height = 1080;\n        video.autoplay = true;\n        item.append(video);\n        // listener for fulscreen view of a participants video\n        f.addEventListener(\"click\", (e) => {\n            let elem = video;\n            if (!document.fullscreenElement) {\n                elem.requestFullscreen().catch(err => {\n                    alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);\n                });\n            }\n            else {\n                document.exitFullscreen();\n            }\n        });\n        r.addEventListener(\"click\", (e) => {\n            let s = e.target;\n            s.classList.toggle(\"flash\");\n            this.recordStream(s.dataset.peerid);\n        });\n        // beta only supports one participant..\n        if (this.participants.size > 1)\n            r.classList.add(\"hide\");\n        document.querySelector(\"#remote-videos\").append(item);\n        video.addEventListener(\"click\", (e) => {\n            this.fullScreenVideo.play();\n            this.fullScreenVideo.srcObject = e.target.srcObject;\n        });\n    }\n    getMediaDevices() {\n        return new Promise((resolve, reject) => {\n            navigator.mediaDevices.enumerateDevices().then((devices) => {\n                resolve(devices);\n            }).catch(reject);\n        });\n    }\n    ;\n    /**\n     *  Add aparticipant to the \"conference\"\n     *\n     * @param {string} id\n     * @returns {AppParticipant}\n     * @memberof App\n     */\n    tryAddParticipant(id) {\n        if (this.participants.has(id)) {\n            return this.participants.get(id);\n        }\n        else {\n            this.participants.set(id, new AppParticipant_1.AppParticipant(id));\n            let p = this.participants.get(id);\n            p.onVideoTrackAdded = (id, mediaStream, mediaStreamTrack) => {\n                this.addRemoteVideo(id, mediaStream);\n            };\n            return p;\n        }\n    }\n    static getInstance() {\n        return new App();\n    }\n}\nexports.App = App;\n/*\n    Launch the application\n*/\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    if (!(location.href.includes(\"https://\") || location.href.includes(\"http://localhost\")))\n        location.href = location.href.replace(\"http://\", \"https://\");\n    App.getInstance();\n});\n\n\n//# sourceURL=webpack:///./client/app.js?");

/***/ }),

/***/ "./client/settings.json":
/*!******************************!*\
  !*** ./client/settings.json ***!
  \******************************/
/*! exports provided: domain, contextPrefix, serverUrl, version, default */
/***/ (function(module) {

eval("module.exports = {\"domain\":\"Kollokvium\",\"contextPrefix\":\"kollokvium\",\"serverUrl\":\"wss://kollokvium.herokuapp.com\",\"version\":\"1.0.5\"};\n\n//# sourceURL=webpack:///./client/settings.json?");

/***/ }),

/***/ "./node_modules/clipboard/dist/clipboard.js":
/*!**************************************************!*\
  !*** ./node_modules/clipboard/dist/clipboard.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * clipboard.js v2.0.6\n * https://clipboardjs.com/\n * \n * Licensed MIT Â© Zeno Rocha\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nfunction select(element) {\n    var selectedText;\n\n    if (element.nodeName === 'SELECT') {\n        element.focus();\n\n        selectedText = element.value;\n    }\n    else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {\n        var isReadOnly = element.hasAttribute('readonly');\n\n        if (!isReadOnly) {\n            element.setAttribute('readonly', '');\n        }\n\n        element.select();\n        element.setSelectionRange(0, element.value.length);\n\n        if (!isReadOnly) {\n            element.removeAttribute('readonly');\n        }\n\n        selectedText = element.value;\n    }\n    else {\n        if (element.hasAttribute('contenteditable')) {\n            element.focus();\n        }\n\n        var selection = window.getSelection();\n        var range = document.createRange();\n\n        range.selectNodeContents(element);\n        selection.removeAllRanges();\n        selection.addRange(range);\n\n        selectedText = selection.toString();\n    }\n\n    return selectedText;\n}\n\nmodule.exports = select;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nfunction E () {\n  // Keep this empty so it's easier to inherit from\n  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n}\n\nE.prototype = {\n  on: function (name, callback, ctx) {\n    var e = this.e || (this.e = {});\n\n    (e[name] || (e[name] = [])).push({\n      fn: callback,\n      ctx: ctx\n    });\n\n    return this;\n  },\n\n  once: function (name, callback, ctx) {\n    var self = this;\n    function listener () {\n      self.off(name, listener);\n      callback.apply(ctx, arguments);\n    };\n\n    listener._ = callback\n    return this.on(name, listener, ctx);\n  },\n\n  emit: function (name) {\n    var data = [].slice.call(arguments, 1);\n    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n    var i = 0;\n    var len = evtArr.length;\n\n    for (i; i < len; i++) {\n      evtArr[i].fn.apply(evtArr[i].ctx, data);\n    }\n\n    return this;\n  },\n\n  off: function (name, callback) {\n    var e = this.e || (this.e = {});\n    var evts = e[name];\n    var liveEvents = [];\n\n    if (evts && callback) {\n      for (var i = 0, len = evts.length; i < len; i++) {\n        if (evts[i].fn !== callback && evts[i].fn._ !== callback)\n          liveEvents.push(evts[i]);\n      }\n    }\n\n    // Remove event from queue to prevent memory leak\n    // Suggested by https://github.com/lazd\n    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n    (liveEvents.length)\n      ? e[name] = liveEvents\n      : delete e[name];\n\n    return this;\n  }\n};\n\nmodule.exports = E;\nmodule.exports.TinyEmitter = E;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar is = __webpack_require__(3);\nvar delegate = __webpack_require__(4);\n\n/**\n * Validates all params and calls the right\n * listener function based on its target type.\n *\n * @param {String|HTMLElement|HTMLCollection|NodeList} target\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */\nfunction listen(target, type, callback) {\n    if (!target && !type && !callback) {\n        throw new Error('Missing required arguments');\n    }\n\n    if (!is.string(type)) {\n        throw new TypeError('Second argument must be a String');\n    }\n\n    if (!is.fn(callback)) {\n        throw new TypeError('Third argument must be a Function');\n    }\n\n    if (is.node(target)) {\n        return listenNode(target, type, callback);\n    }\n    else if (is.nodeList(target)) {\n        return listenNodeList(target, type, callback);\n    }\n    else if (is.string(target)) {\n        return listenSelector(target, type, callback);\n    }\n    else {\n        throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');\n    }\n}\n\n/**\n * Adds an event listener to a HTML element\n * and returns a remove listener function.\n *\n * @param {HTMLElement} node\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */\nfunction listenNode(node, type, callback) {\n    node.addEventListener(type, callback);\n\n    return {\n        destroy: function() {\n            node.removeEventListener(type, callback);\n        }\n    }\n}\n\n/**\n * Add an event listener to a list of HTML elements\n * and returns a remove listener function.\n *\n * @param {NodeList|HTMLCollection} nodeList\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */\nfunction listenNodeList(nodeList, type, callback) {\n    Array.prototype.forEach.call(nodeList, function(node) {\n        node.addEventListener(type, callback);\n    });\n\n    return {\n        destroy: function() {\n            Array.prototype.forEach.call(nodeList, function(node) {\n                node.removeEventListener(type, callback);\n            });\n        }\n    }\n}\n\n/**\n * Add an event listener to a selector\n * and returns a remove listener function.\n *\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */\nfunction listenSelector(selector, type, callback) {\n    return delegate(document.body, selector, type, callback);\n}\n\nmodule.exports = listen;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n/**\n * Check if argument is a HTML element.\n *\n * @param {Object} value\n * @return {Boolean}\n */\nexports.node = function(value) {\n    return value !== undefined\n        && value instanceof HTMLElement\n        && value.nodeType === 1;\n};\n\n/**\n * Check if argument is a list of HTML elements.\n *\n * @param {Object} value\n * @return {Boolean}\n */\nexports.nodeList = function(value) {\n    var type = Object.prototype.toString.call(value);\n\n    return value !== undefined\n        && (type === '[object NodeList]' || type === '[object HTMLCollection]')\n        && ('length' in value)\n        && (value.length === 0 || exports.node(value[0]));\n};\n\n/**\n * Check if argument is a string.\n *\n * @param {Object} value\n * @return {Boolean}\n */\nexports.string = function(value) {\n    return typeof value === 'string'\n        || value instanceof String;\n};\n\n/**\n * Check if argument is a function.\n *\n * @param {Object} value\n * @return {Boolean}\n */\nexports.fn = function(value) {\n    var type = Object.prototype.toString.call(value);\n\n    return type === '[object Function]';\n};\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar closest = __webpack_require__(5);\n\n/**\n * Delegates event to a selector.\n *\n * @param {Element} element\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @param {Boolean} useCapture\n * @return {Object}\n */\nfunction _delegate(element, selector, type, callback, useCapture) {\n    var listenerFn = listener.apply(this, arguments);\n\n    element.addEventListener(type, listenerFn, useCapture);\n\n    return {\n        destroy: function() {\n            element.removeEventListener(type, listenerFn, useCapture);\n        }\n    }\n}\n\n/**\n * Delegates event to a selector.\n *\n * @param {Element|String|Array} [elements]\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @param {Boolean} useCapture\n * @return {Object}\n */\nfunction delegate(elements, selector, type, callback, useCapture) {\n    // Handle the regular Element usage\n    if (typeof elements.addEventListener === 'function') {\n        return _delegate.apply(null, arguments);\n    }\n\n    // Handle Element-less usage, it defaults to global delegation\n    if (typeof type === 'function') {\n        // Use `document` as the first parameter, then apply arguments\n        // This is a short way to .unshift `arguments` without running into deoptimizations\n        return _delegate.bind(null, document).apply(null, arguments);\n    }\n\n    // Handle Selector-based usage\n    if (typeof elements === 'string') {\n        elements = document.querySelectorAll(elements);\n    }\n\n    // Handle Array-like based usage\n    return Array.prototype.map.call(elements, function (element) {\n        return _delegate(element, selector, type, callback, useCapture);\n    });\n}\n\n/**\n * Finds closest match and invokes callback.\n *\n * @param {Element} element\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @return {Function}\n */\nfunction listener(element, selector, type, callback) {\n    return function(e) {\n        e.delegateTarget = closest(e.target, selector);\n\n        if (e.delegateTarget) {\n            callback.call(element, e);\n        }\n    }\n}\n\nmodule.exports = delegate;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nvar DOCUMENT_NODE_TYPE = 9;\n\n/**\n * A polyfill for Element.matches()\n */\nif (typeof Element !== 'undefined' && !Element.prototype.matches) {\n    var proto = Element.prototype;\n\n    proto.matches = proto.matchesSelector ||\n                    proto.mozMatchesSelector ||\n                    proto.msMatchesSelector ||\n                    proto.oMatchesSelector ||\n                    proto.webkitMatchesSelector;\n}\n\n/**\n * Finds the closest parent that matches a selector.\n *\n * @param {Element} element\n * @param {String} selector\n * @return {Function}\n */\nfunction closest (element, selector) {\n    while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {\n        if (typeof element.matches === 'function' &&\n            element.matches(selector)) {\n          return element;\n        }\n        element = element.parentNode;\n    }\n}\n\nmodule.exports = closest;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/select/src/select.js\nvar src_select = __webpack_require__(0);\nvar select_default = /*#__PURE__*/__webpack_require__.n(src_select);\n\n// CONCATENATED MODULE: ./src/clipboard-action.js\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n/**\n * Inner class which performs selection from either `text` or `target`\n * properties and then executes copy or cut operations.\n */\n\nvar clipboard_action_ClipboardAction = function () {\n    /**\n     * @param {Object} options\n     */\n    function ClipboardAction(options) {\n        _classCallCheck(this, ClipboardAction);\n\n        this.resolveOptions(options);\n        this.initSelection();\n    }\n\n    /**\n     * Defines base properties passed from constructor.\n     * @param {Object} options\n     */\n\n\n    _createClass(ClipboardAction, [{\n        key: 'resolveOptions',\n        value: function resolveOptions() {\n            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            this.action = options.action;\n            this.container = options.container;\n            this.emitter = options.emitter;\n            this.target = options.target;\n            this.text = options.text;\n            this.trigger = options.trigger;\n\n            this.selectedText = '';\n        }\n\n        /**\n         * Decides which selection strategy is going to be applied based\n         * on the existence of `text` and `target` properties.\n         */\n\n    }, {\n        key: 'initSelection',\n        value: function initSelection() {\n            if (this.text) {\n                this.selectFake();\n            } else if (this.target) {\n                this.selectTarget();\n            }\n        }\n\n        /**\n         * Creates a fake textarea element, sets its value from `text` property,\n         * and makes a selection on it.\n         */\n\n    }, {\n        key: 'selectFake',\n        value: function selectFake() {\n            var _this = this;\n\n            var isRTL = document.documentElement.getAttribute('dir') == 'rtl';\n\n            this.removeFake();\n\n            this.fakeHandlerCallback = function () {\n                return _this.removeFake();\n            };\n            this.fakeHandler = this.container.addEventListener('click', this.fakeHandlerCallback) || true;\n\n            this.fakeElem = document.createElement('textarea');\n            // Prevent zooming on iOS\n            this.fakeElem.style.fontSize = '12pt';\n            // Reset box model\n            this.fakeElem.style.border = '0';\n            this.fakeElem.style.padding = '0';\n            this.fakeElem.style.margin = '0';\n            // Move element out of screen horizontally\n            this.fakeElem.style.position = 'absolute';\n            this.fakeElem.style[isRTL ? 'right' : 'left'] = '-9999px';\n            // Move element to the same position vertically\n            var yPosition = window.pageYOffset || document.documentElement.scrollTop;\n            this.fakeElem.style.top = yPosition + 'px';\n\n            this.fakeElem.setAttribute('readonly', '');\n            this.fakeElem.value = this.text;\n\n            this.container.appendChild(this.fakeElem);\n\n            this.selectedText = select_default()(this.fakeElem);\n            this.copyText();\n        }\n\n        /**\n         * Only removes the fake element after another click event, that way\n         * a user can hit `Ctrl+C` to copy because selection still exists.\n         */\n\n    }, {\n        key: 'removeFake',\n        value: function removeFake() {\n            if (this.fakeHandler) {\n                this.container.removeEventListener('click', this.fakeHandlerCallback);\n                this.fakeHandler = null;\n                this.fakeHandlerCallback = null;\n            }\n\n            if (this.fakeElem) {\n                this.container.removeChild(this.fakeElem);\n                this.fakeElem = null;\n            }\n        }\n\n        /**\n         * Selects the content from element passed on `target` property.\n         */\n\n    }, {\n        key: 'selectTarget',\n        value: function selectTarget() {\n            this.selectedText = select_default()(this.target);\n            this.copyText();\n        }\n\n        /**\n         * Executes the copy operation based on the current selection.\n         */\n\n    }, {\n        key: 'copyText',\n        value: function copyText() {\n            var succeeded = void 0;\n\n            try {\n                succeeded = document.execCommand(this.action);\n            } catch (err) {\n                succeeded = false;\n            }\n\n            this.handleResult(succeeded);\n        }\n\n        /**\n         * Fires an event based on the copy operation result.\n         * @param {Boolean} succeeded\n         */\n\n    }, {\n        key: 'handleResult',\n        value: function handleResult(succeeded) {\n            this.emitter.emit(succeeded ? 'success' : 'error', {\n                action: this.action,\n                text: this.selectedText,\n                trigger: this.trigger,\n                clearSelection: this.clearSelection.bind(this)\n            });\n        }\n\n        /**\n         * Moves focus away from `target` and back to the trigger, removes current selection.\n         */\n\n    }, {\n        key: 'clearSelection',\n        value: function clearSelection() {\n            if (this.trigger) {\n                this.trigger.focus();\n            }\n            document.activeElement.blur();\n            window.getSelection().removeAllRanges();\n        }\n\n        /**\n         * Sets the `action` to be performed which can be either 'copy' or 'cut'.\n         * @param {String} action\n         */\n\n    }, {\n        key: 'destroy',\n\n\n        /**\n         * Destroy lifecycle.\n         */\n        value: function destroy() {\n            this.removeFake();\n        }\n    }, {\n        key: 'action',\n        set: function set() {\n            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'copy';\n\n            this._action = action;\n\n            if (this._action !== 'copy' && this._action !== 'cut') {\n                throw new Error('Invalid \"action\" value, use either \"copy\" or \"cut\"');\n            }\n        }\n\n        /**\n         * Gets the `action` property.\n         * @return {String}\n         */\n        ,\n        get: function get() {\n            return this._action;\n        }\n\n        /**\n         * Sets the `target` property using an element\n         * that will be have its content copied.\n         * @param {Element} target\n         */\n\n    }, {\n        key: 'target',\n        set: function set(target) {\n            if (target !== undefined) {\n                if (target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && target.nodeType === 1) {\n                    if (this.action === 'copy' && target.hasAttribute('disabled')) {\n                        throw new Error('Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute');\n                    }\n\n                    if (this.action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {\n                        throw new Error('Invalid \"target\" attribute. You can\\'t cut text from elements with \"readonly\" or \"disabled\" attributes');\n                    }\n\n                    this._target = target;\n                } else {\n                    throw new Error('Invalid \"target\" value, use a valid Element');\n                }\n            }\n        }\n\n        /**\n         * Gets the `target` property.\n         * @return {String|HTMLElement}\n         */\n        ,\n        get: function get() {\n            return this._target;\n        }\n    }]);\n\n    return ClipboardAction;\n}();\n\n/* harmony default export */ var clipboard_action = (clipboard_action_ClipboardAction);\n// EXTERNAL MODULE: ./node_modules/tiny-emitter/index.js\nvar tiny_emitter = __webpack_require__(1);\nvar tiny_emitter_default = /*#__PURE__*/__webpack_require__.n(tiny_emitter);\n\n// EXTERNAL MODULE: ./node_modules/good-listener/src/listen.js\nvar listen = __webpack_require__(2);\nvar listen_default = /*#__PURE__*/__webpack_require__.n(listen);\n\n// CONCATENATED MODULE: ./src/clipboard.js\nvar clipboard_typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar clipboard_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction clipboard_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n/**\n * Base class which takes one or more elements, adds event listeners to them,\n * and instantiates a new `ClipboardAction` on each click.\n */\n\nvar clipboard_Clipboard = function (_Emitter) {\n    _inherits(Clipboard, _Emitter);\n\n    /**\n     * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\n     * @param {Object} options\n     */\n    function Clipboard(trigger, options) {\n        clipboard_classCallCheck(this, Clipboard);\n\n        var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this));\n\n        _this.resolveOptions(options);\n        _this.listenClick(trigger);\n        return _this;\n    }\n\n    /**\n     * Defines if attributes would be resolved using internal setter functions\n     * or custom functions that were passed in the constructor.\n     * @param {Object} options\n     */\n\n\n    clipboard_createClass(Clipboard, [{\n        key: 'resolveOptions',\n        value: function resolveOptions() {\n            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            this.action = typeof options.action === 'function' ? options.action : this.defaultAction;\n            this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;\n            this.text = typeof options.text === 'function' ? options.text : this.defaultText;\n            this.container = clipboard_typeof(options.container) === 'object' ? options.container : document.body;\n        }\n\n        /**\n         * Adds a click event listener to the passed trigger.\n         * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\n         */\n\n    }, {\n        key: 'listenClick',\n        value: function listenClick(trigger) {\n            var _this2 = this;\n\n            this.listener = listen_default()(trigger, 'click', function (e) {\n                return _this2.onClick(e);\n            });\n        }\n\n        /**\n         * Defines a new `ClipboardAction` on each click event.\n         * @param {Event} e\n         */\n\n    }, {\n        key: 'onClick',\n        value: function onClick(e) {\n            var trigger = e.delegateTarget || e.currentTarget;\n\n            if (this.clipboardAction) {\n                this.clipboardAction = null;\n            }\n\n            this.clipboardAction = new clipboard_action({\n                action: this.action(trigger),\n                target: this.target(trigger),\n                text: this.text(trigger),\n                container: this.container,\n                trigger: trigger,\n                emitter: this\n            });\n        }\n\n        /**\n         * Default `action` lookup function.\n         * @param {Element} trigger\n         */\n\n    }, {\n        key: 'defaultAction',\n        value: function defaultAction(trigger) {\n            return getAttributeValue('action', trigger);\n        }\n\n        /**\n         * Default `target` lookup function.\n         * @param {Element} trigger\n         */\n\n    }, {\n        key: 'defaultTarget',\n        value: function defaultTarget(trigger) {\n            var selector = getAttributeValue('target', trigger);\n\n            if (selector) {\n                return document.querySelector(selector);\n            }\n        }\n\n        /**\n         * Returns the support of the given action, or all actions if no action is\n         * given.\n         * @param {String} [action]\n         */\n\n    }, {\n        key: 'defaultText',\n\n\n        /**\n         * Default `text` lookup function.\n         * @param {Element} trigger\n         */\n        value: function defaultText(trigger) {\n            return getAttributeValue('text', trigger);\n        }\n\n        /**\n         * Destroy lifecycle.\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this.listener.destroy();\n\n            if (this.clipboardAction) {\n                this.clipboardAction.destroy();\n                this.clipboardAction = null;\n            }\n        }\n    }], [{\n        key: 'isSupported',\n        value: function isSupported() {\n            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];\n\n            var actions = typeof action === 'string' ? [action] : action;\n            var support = !!document.queryCommandSupported;\n\n            actions.forEach(function (action) {\n                support = support && !!document.queryCommandSupported(action);\n            });\n\n            return support;\n        }\n    }]);\n\n    return Clipboard;\n}(tiny_emitter_default.a);\n\n/**\n * Helper function to retrieve attribute value.\n * @param {String} suffix\n * @param {Element} element\n */\n\n\nfunction getAttributeValue(suffix, element) {\n    var attribute = 'data-clipboard-' + suffix;\n\n    if (!element.hasAttribute(attribute)) {\n        return;\n    }\n\n    return element.getAttribute(attribute);\n}\n\n/* harmony default export */ var clipboard = __webpack_exports__[\"default\"] = (clipboard_Clipboard);\n\n/***/ })\n/******/ ])[\"default\"];\n});\n\n//# sourceURL=webpack:///./node_modules/clipboard/dist/clipboard.js?");

/***/ }),

/***/ "./node_modules/thor-io.client-vnext/index.js":
/*!****************************************************!*\
  !*** ./node_modules/thor-io.client-vnext/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BandwidthConstraints_1 = __webpack_require__(/*! ./src/WebRTC/BandwidthConstraints */ \"./node_modules/thor-io.client-vnext/src/WebRTC/BandwidthConstraints.js\");\nexports.BandwidthConstraints = BandwidthConstraints_1.BandwidthConstraints;\nvar BinaryMessage_1 = __webpack_require__(/*! ./src/Messages/BinaryMessage */ \"./node_modules/thor-io.client-vnext/src/Messages/BinaryMessage.js\");\nexports.BinaryMessage = BinaryMessage_1.BinaryMessage;\nvar DataChannel_1 = __webpack_require__(/*! ./src/WebRTC/DataChannel */ \"./node_modules/thor-io.client-vnext/src/WebRTC/DataChannel.js\");\nexports.DataChannel = DataChannel_1.DataChannel;\nvar Factory_1 = __webpack_require__(/*! ./src/Factory */ \"./node_modules/thor-io.client-vnext/src/Factory.js\");\nexports.Factory = Factory_1.Factory;\nvar TextMessage_1 = __webpack_require__(/*! ./src/Messages/TextMessage */ \"./node_modules/thor-io.client-vnext/src/Messages/TextMessage.js\");\nexports.Message = TextMessage_1.TextMessage;\nvar Listener_1 = __webpack_require__(/*! ./src/Listener */ \"./node_modules/thor-io.client-vnext/src/Listener.js\");\nexports.Listener = Listener_1.Listener;\nvar PeerChannel_1 = __webpack_require__(/*! ./src/WebRTC/PeerChannel */ \"./node_modules/thor-io.client-vnext/src/WebRTC/PeerChannel.js\");\nexports.PeerChannel = PeerChannel_1.PeerChannel;\nvar PropertyMessage_1 = __webpack_require__(/*! ./src/Messages/PropertyMessage */ \"./node_modules/thor-io.client-vnext/src/Messages/PropertyMessage.js\");\nexports.PropertyMessage = PropertyMessage_1.PropertyMessage;\nvar Controller_1 = __webpack_require__(/*! ./src/Controller */ \"./node_modules/thor-io.client-vnext/src/Controller.js\");\nexports.Proxy = Controller_1.Controller;\nvar Utils_1 = __webpack_require__(/*! ./src/Utils/Utils */ \"./node_modules/thor-io.client-vnext/src/Utils/Utils.js\");\nexports.Utils = Utils_1.Utils;\nvar WebRTC_1 = __webpack_require__(/*! ./src/WebRTC/WebRTC */ \"./node_modules/thor-io.client-vnext/src/WebRTC/WebRTC.js\");\nexports.WebRTC = WebRTC_1.WebRTC;\n\n\n//# sourceURL=webpack:///./node_modules/thor-io.client-vnext/index.js?");

/***/ }),

/***/ "./node_modules/thor-io.client-vnext/src/Controller.js":
/*!*************************************************************!*\
  !*** ./node_modules/thor-io.client-vnext/src/Controller.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TextMessage_1 = __webpack_require__(/*! ./Messages/TextMessage */ \"./node_modules/thor-io.client-vnext/src/Messages/TextMessage.js\");\nvar Listener_1 = __webpack_require__(/*! ./Listener */ \"./node_modules/thor-io.client-vnext/src/Listener.js\");\nvar Controller = (function () {\n    function Controller(alias, ws) {\n        var _this = this;\n        this.alias = alias;\n        this.ws = ws;\n        this.listeners = new Array();\n        this.IsConnected = false;\n        this.On(\"___error\", function (err) {\n            _this.OnError(err);\n        });\n    }\n    Controller.prototype.OnError = function (event) { };\n    Controller.prototype.OnOpen = function (event) { };\n    Controller.prototype.OnClose = function (event) { };\n    Controller.prototype.Connect = function () {\n        this.ws.send(new TextMessage_1.TextMessage(\"___connect\", {}, this.alias).toString());\n        return this;\n    };\n    ;\n    Controller.prototype.Close = function () {\n        this.ws.send(new TextMessage_1.TextMessage(\"___close\", {}, this.alias).toString());\n        return this;\n    };\n    ;\n    Controller.prototype.Subscribe = function (topic, callback) {\n        this.ws.send(new TextMessage_1.TextMessage(\"___subscribe\", {\n            topic: topic,\n            controller: this.alias\n        }, this.alias).toString());\n        return this.On(topic, callback);\n    };\n    Controller.prototype.Unsubscribe = function (topic) {\n        this.ws.send(new TextMessage_1.TextMessage(\"___unsubscribe\", {\n            topic: topic,\n            controller: this.alias\n        }, this.alias).toString());\n    };\n    Controller.prototype.On = function (topic, fn) {\n        var listener = new Listener_1.Listener(topic, fn);\n        this.listeners.push(listener);\n        return listener;\n    };\n    Controller.prototype.Off = function (topic) {\n        var index = this.listeners.indexOf(this.findListener(topic));\n        if (index >= 0)\n            this.listeners.splice(index, 1);\n    };\n    Controller.prototype.findListener = function (topic) {\n        var listener = this.listeners.find(function (pre) {\n            return pre.topic === topic;\n        });\n        return listener;\n    };\n    Controller.prototype.InvokeBinary = function (buffer) {\n        if (buffer instanceof ArrayBuffer) {\n            this.ws.send(buffer);\n            return this;\n        }\n        else {\n            throw (\"parameter provided must be an ArrayBuffer constructed by Client.BinaryMessage\");\n        }\n    };\n    Controller.prototype.PublishBinary = function (buffer) {\n        if (buffer instanceof ArrayBuffer) {\n            this.ws.send(buffer);\n            return this;\n        }\n        else {\n            throw (\"parameter provided must be an ArrayBuffer constructed by Client.BinaryMessage\");\n        }\n    };\n    Controller.prototype.Invoke = function (method, data, controller) {\n        this.ws.send(new TextMessage_1.TextMessage(method, data, controller || this.alias).toString());\n        return this;\n    };\n    Controller.prototype.Publish = function (topic, data, controller) {\n        this.Invoke(topic, data, controller || this.alias);\n        return this;\n    };\n    Controller.prototype.SetProperty = function (propName, propValue, controller) {\n        this.Invoke(propName, propValue, controller || this.alias);\n        return this;\n    };\n    Controller.prototype.Dispatch = function (topic, data, buffer) {\n        if (topic === \"___open\") {\n            this.IsConnected = true;\n            this.OnOpen(JSON.parse(data));\n            return;\n        }\n        else if (topic === \"___close\") {\n            this.OnClose([JSON.parse(data)]);\n            this.IsConnected = false;\n        }\n        else {\n            var listener = this.findListener(topic);\n            if (listener)\n                listener.fn(JSON.parse(data), buffer);\n        }\n    };\n    return Controller;\n}());\nexports.Controller = Controller;\n\n\n//# sourceURL=webpack:///./node_modules/thor-io.client-vnext/src/Controller.js?");

/***/ }),

/***/ "./node_modules/thor-io.client-vnext/src/Factory.js":
/*!**********************************************************!*\
  !*** ./node_modules/thor-io.client-vnext/src/Factory.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BinaryMessage_1 = __webpack_require__(/*! ./Messages/BinaryMessage */ \"./node_modules/thor-io.client-vnext/src/Messages/BinaryMessage.js\");\nvar Controller_1 = __webpack_require__(/*! ./Controller */ \"./node_modules/thor-io.client-vnext/src/Controller.js\");\nvar Factory = (function () {\n    function Factory(url, controllers, params) {\n        var _this = this;\n        this.url = url;\n        this.controllers = new Map();\n        this.ws = new WebSocket(url + this.toQuery(params || {}));\n        this.ws.binaryType = \"arraybuffer\";\n        controllers.forEach(function (alias) {\n            _this.controllers.set(alias, new Controller_1.Controller(alias, _this.ws));\n        });\n        this.ws.onmessage = function (event) {\n            if (typeof (event.data) !== \"object\") {\n                var message = JSON.parse(event.data);\n                _this.GetController(message.C).Dispatch(message.T, message.D);\n            }\n            else {\n                var message = BinaryMessage_1.BinaryMessage.fromArrayBuffer(event.data);\n                _this.GetController(message.C).Dispatch(message.T, message.D, message.B);\n            }\n        };\n        this.ws.onclose = function (event) {\n            _this.IsConnected = false;\n            _this.OnClose.apply(_this, [event]);\n        };\n        this.ws.onerror = function (error) {\n            _this.OnError.apply(_this, [error]);\n        };\n        this.ws.onopen = function (event) {\n            _this.IsConnected = true;\n            _this.OnOpen.apply(_this, Array.from(_this.controllers.values()));\n        };\n    }\n    Factory.prototype.toQuery = function (obj) {\n        return \"?\" + Object.keys(obj).map(function (key) { return (encodeURIComponent(key) + \"=\" +\n            encodeURIComponent(obj[key])); }).join(\"&\");\n    };\n    Factory.prototype.Close = function () {\n        this.ws.close();\n    };\n    Factory.prototype.GetController = function (alias) {\n        return this.controllers.get(alias);\n    };\n    Factory.prototype.RemoveController = function (alias) {\n        this.controllers.delete(alias);\n    };\n    Factory.prototype.OnOpen = function (controllers) { };\n    Factory.prototype.OnError = function (error) { };\n    Factory.prototype.OnClose = function (event) { };\n    return Factory;\n}());\nexports.Factory = Factory;\n\n\n//# sourceURL=webpack:///./node_modules/thor-io.client-vnext/src/Factory.js?");

/***/ }),

/***/ "./node_modules/thor-io.client-vnext/src/Listener.js":
/*!***********************************************************!*\
  !*** ./node_modules/thor-io.client-vnext/src/Listener.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Listener = (function () {\n    function Listener(topic, fn) {\n        this.fn = fn;\n        this.topic = topic;\n        this.count = 0;\n    }\n    return Listener;\n}());\nexports.Listener = Listener;\n\n\n//# sourceURL=webpack:///./node_modules/thor-io.client-vnext/src/Listener.js?");

/***/ }),

/***/ "./node_modules/thor-io.client-vnext/src/Messages/BinaryMessage.js":
/*!*************************************************************************!*\
  !*** ./node_modules/thor-io.client-vnext/src/Messages/BinaryMessage.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Utils_1 = __webpack_require__(/*! ../Utils/Utils */ \"./node_modules/thor-io.client-vnext/src/Utils/Utils.js\");\nvar TextMessage_1 = __webpack_require__(/*! ./TextMessage */ \"./node_modules/thor-io.client-vnext/src/Messages/TextMessage.js\");\nvar BinaryMessage = (function () {\n    function BinaryMessage(message, arrayBuffer) {\n        this.arrayBuffer = arrayBuffer;\n        this.header = new Uint8Array(Utils_1.Utils.longToArray(message.length));\n        this.Buffer = this.joinBuffers(this.joinBuffers(this.header.buffer, Utils_1.Utils.stingToBuffer(message).buffer), arrayBuffer);\n    }\n    BinaryMessage.fromArrayBuffer = function (buffer) {\n        var bytes = new Uint8Array(buffer);\n        var header = bytes.slice(0, 8);\n        var payloadLength = Utils_1.Utils.arrayToLong(header);\n        var start = header.byteLength + payloadLength;\n        var bytesMessage = bytes.slice(header.byteLength, start);\n        var stop = buffer.byteLength - start;\n        var messageBuffer = bytes.slice(start, stop);\n        var message = JSON.parse(String.fromCharCode.apply(null, new Uint16Array(bytesMessage)));\n        return new TextMessage_1.TextMessage(message.T, message.D, message.C, messageBuffer);\n    };\n    BinaryMessage.prototype.joinBuffers = function (a, b) {\n        var newBuffer = new Uint8Array(a.byteLength + b.byteLength);\n        newBuffer.set(new Uint8Array(a), 0);\n        newBuffer.set(new Uint8Array(b), a.byteLength);\n        return newBuffer.buffer;\n    };\n    return BinaryMessage;\n}());\nexports.BinaryMessage = BinaryMessage;\n\n\n//# sourceURL=webpack:///./node_modules/thor-io.client-vnext/src/Messages/BinaryMessage.js?");

/***/ }),

/***/ "./node_modules/thor-io.client-vnext/src/Messages/PropertyMessage.js":
/*!***************************************************************************!*\
  !*** ./node_modules/thor-io.client-vnext/src/Messages/PropertyMessage.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Utils_1 = __webpack_require__(/*! ../Utils/Utils */ \"./node_modules/thor-io.client-vnext/src/Utils/Utils.js\");\nvar PropertyMessage = (function () {\n    function PropertyMessage() {\n        this.messageId = Utils_1.Utils.newGuid();\n    }\n    return PropertyMessage;\n}());\nexports.PropertyMessage = PropertyMessage;\n\n\n//# sourceURL=webpack:///./node_modules/thor-io.client-vnext/src/Messages/PropertyMessage.js?");

/***/ }),

/***/ "./node_modules/thor-io.client-vnext/src/Messages/TextMessage.js":
/*!***********************************************************************!*\
  !*** ./node_modules/thor-io.client-vnext/src/Messages/TextMessage.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BinaryMessage_1 = __webpack_require__(/*! ./BinaryMessage */ \"./node_modules/thor-io.client-vnext/src/Messages/BinaryMessage.js\");\nvar TextMessage = (function () {\n    function TextMessage(topic, object, controller, buffer) {\n        this.D = object;\n        this.T = topic;\n        this.C = controller;\n        this.B = buffer;\n    }\n    Object.defineProperty(TextMessage.prototype, \"JSON\", {\n        get: function () {\n            return {\n                T: this.T,\n                D: JSON.stringify(this.D),\n                C: this.C\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TextMessage.prototype.toString = function () {\n        return JSON.stringify(this.JSON);\n    };\n    TextMessage.fromArrayBuffer = function (buffer) {\n        return BinaryMessage_1.BinaryMessage.fromArrayBuffer(buffer);\n    };\n    return TextMessage;\n}());\nexports.TextMessage = TextMessage;\n\n\n//# sourceURL=webpack:///./node_modules/thor-io.client-vnext/src/Messages/TextMessage.js?");

/***/ }),

/***/ "./node_modules/thor-io.client-vnext/src/Utils/Utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/thor-io.client-vnext/src/Utils/Utils.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Utils = (function () {\n    function Utils() {\n    }\n    Utils.stingToBuffer = function (str) {\n        var len = str.length;\n        var arr = new Array(len);\n        for (var i = 0; i < len; i++) {\n            arr[i] = str.charCodeAt(i) & 0xFF;\n        }\n        return new Uint8Array(arr);\n    };\n    Utils.arrayToLong = function (byteArray) {\n        var value = 0;\n        var byteLength = byteArray.byteLength;\n        for (var i = byteLength - 1; i >= 0; i--) {\n            value = (value * 256) + byteArray[i];\n        }\n        return value;\n    };\n    Utils.longToArray = function (long) {\n        var byteArray = new Uint8Array(8);\n        var byteLength = byteArray.length;\n        for (var index = 0; index < byteLength; index++) {\n            var byte = long & 0xff;\n            byteArray[index] = byte;\n            long = (long - byte) / 256;\n        }\n        return byteArray;\n    };\n    Utils.newGuid = function () {\n        var s4 = function () {\n            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n        };\n        return s4() + s4() + \"-\" + s4() + \"-\" + s4() + \"-\" + s4() + \"-\" + s4() + s4() + s4();\n    };\n    return Utils;\n}());\nexports.Utils = Utils;\n\n\n//# sourceURL=webpack:///./node_modules/thor-io.client-vnext/src/Utils/Utils.js?");

/***/ }),

/***/ "./node_modules/thor-io.client-vnext/src/WebRTC/BandwidthConstraints.js":
/*!******************************************************************************!*\
  !*** ./node_modules/thor-io.client-vnext/src/WebRTC/BandwidthConstraints.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BandwidthConstraints = (function () {\n    function BandwidthConstraints(videobandwidth, audiobandwidth) {\n        this.videobandwidth = videobandwidth;\n        this.audiobandwidth = audiobandwidth;\n    }\n    return BandwidthConstraints;\n}());\nexports.BandwidthConstraints = BandwidthConstraints;\n\n\n//# sourceURL=webpack:///./node_modules/thor-io.client-vnext/src/WebRTC/BandwidthConstraints.js?");

/***/ }),

/***/ "./node_modules/thor-io.client-vnext/src/WebRTC/DataChannel.js":
/*!*********************************************************************!*\
  !*** ./node_modules/thor-io.client-vnext/src/WebRTC/DataChannel.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TextMessage_1 = __webpack_require__(/*! ../Messages/TextMessage */ \"./node_modules/thor-io.client-vnext/src/Messages/TextMessage.js\");\nvar Listener_1 = __webpack_require__(/*! ../Listener */ \"./node_modules/thor-io.client-vnext/src/Listener.js\");\nvar DataChannel = (function () {\n    function DataChannel(name, listeners) {\n        this.listeners = listeners || new Array();\n        this.PeerChannels = new Array();\n        this.Name = name;\n    }\n    DataChannel.prototype.findListener = function (topic) {\n        var listener = this.listeners.find(function (pre) {\n            return pre.topic === topic;\n        });\n        return listener;\n    };\n    DataChannel.prototype.On = function (topic, fn) {\n        var listener = new Listener_1.Listener(topic, fn);\n        this.listeners.push(listener);\n        return listener;\n    };\n    DataChannel.prototype.Off = function (topic) {\n        var index = this.listeners.indexOf(this.findListener(topic));\n        if (index >= 0)\n            this.listeners.splice(index, 1);\n    };\n    DataChannel.prototype.OnOpen = function (event, peerId) { };\n    DataChannel.prototype.OnClose = function (event, peerId) { };\n    DataChannel.prototype.onMessage = function (event) {\n        var msg = JSON.parse(event.data);\n        var listener = this.findListener(msg.T);\n        if (listener)\n            listener.fn.apply(this, [JSON.parse(msg.D)]);\n    };\n    DataChannel.prototype.Close = function () {\n        this.PeerChannels.forEach(function (pc) {\n            pc.dataChannel.close();\n        });\n    };\n    DataChannel.prototype.Invoke = function (topic, data, controller) {\n        var _this = this;\n        this.PeerChannels.forEach(function (channel) {\n            if (channel.dataChannel.readyState === \"open\") {\n                channel.dataChannel.send(new TextMessage_1.TextMessage(topic, data, _this.Name).toString());\n            }\n        });\n        return this;\n    };\n    DataChannel.prototype.addPeerChannel = function (pc) {\n        this.PeerChannels.push(pc);\n    };\n    DataChannel.prototype.removePeerChannel = function (id) {\n        var match = this.PeerChannels.find(function (p) {\n            return p.peerId === id;\n        });\n        var index = this.PeerChannels.indexOf(match);\n        if (index > -1)\n            this.PeerChannels.splice(index, 1);\n    };\n    return DataChannel;\n}());\nexports.DataChannel = DataChannel;\n\n\n//# sourceURL=webpack:///./node_modules/thor-io.client-vnext/src/WebRTC/DataChannel.js?");

/***/ }),

/***/ "./node_modules/thor-io.client-vnext/src/WebRTC/PeerChannel.js":
/*!*********************************************************************!*\
  !*** ./node_modules/thor-io.client-vnext/src/WebRTC/PeerChannel.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PeerChannel = (function () {\n    function PeerChannel(peerId, dataChannel, label) {\n        this.peerId = peerId;\n        this.dataChannel = dataChannel;\n        this.label = label;\n    }\n    return PeerChannel;\n}());\nexports.PeerChannel = PeerChannel;\n\n\n//# sourceURL=webpack:///./node_modules/thor-io.client-vnext/src/WebRTC/PeerChannel.js?");

/***/ }),

/***/ "./node_modules/thor-io.client-vnext/src/WebRTC/WebRTC.js":
/*!****************************************************************!*\
  !*** ./node_modules/thor-io.client-vnext/src/WebRTC/WebRTC.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar WebRTCConnection_1 = __webpack_require__(/*! ./WebRTCConnection */ \"./node_modules/thor-io.client-vnext/src/WebRTC/WebRTCConnection.js\");\nvar PeerChannel_1 = __webpack_require__(/*! ./PeerChannel */ \"./node_modules/thor-io.client-vnext/src/WebRTC/PeerChannel.js\");\nvar DataChannel_1 = __webpack_require__(/*! ./DataChannel */ \"./node_modules/thor-io.client-vnext/src/WebRTC/DataChannel.js\");\nvar BandwidthConstraints_1 = __webpack_require__(/*! ./BandwidthConstraints */ \"./node_modules/thor-io.client-vnext/src/WebRTC/BandwidthConstraints.js\");\nvar WebRTC = (function () {\n    function WebRTC(brokerController, rtcConfig) {\n        var _this = this;\n        this.brokerController = brokerController;\n        this.rtcConfig = rtcConfig;\n        this.Errors = new Array();\n        this.LocalStreams = new Array();\n        this.DataChannels = new Map();\n        this.Peers = new Map();\n        this.brokerController.On(\"contextSignal\", function (signal) {\n            var msg = JSON.parse(signal.message);\n            switch (msg.type) {\n                case \"offer\":\n                    _this.onOffer(signal);\n                    break;\n                case \"answer\":\n                    _this.onAnswer(signal);\n                    break;\n                case \"candidate\":\n                    _this.onCandidate(signal);\n                    break;\n            }\n        });\n        brokerController.On(\"contextCreated\", function (peer) {\n            _this.LocalPeerId = peer.peerId;\n            _this.Context = peer.context;\n            _this.OnContextCreated(peer);\n        });\n        brokerController.On(\"contextChanged\", function (context) {\n            _this.Context = context;\n            _this.OnContextChanged(context);\n        });\n        brokerController.On(\"connectTo\", function (peers) {\n            _this.onConnectTo(peers);\n        });\n    }\n    WebRTC.prototype.onConnectTo = function (peerConnections) {\n        this.Connect(peerConnections);\n    };\n    WebRTC.prototype.onConnected = function (peerId) {\n        this.OnContextConnected(this.findPeerConnection(peerId), this.getPeerConnection(peerId));\n    };\n    WebRTC.prototype.OnDisconnected = function (peerId) {\n        var peerConnection = this.getPeerConnection(peerId);\n        this.OnContextDisconnected(this.findPeerConnection(peerId), peerConnection);\n        peerConnection.close();\n        this.removePeerConnection(peerId);\n    };\n    WebRTC.prototype.setBandwithConstraints = function (videobandwidth, audiobandwidth) {\n        this.bandwidthConstraints = new BandwidthConstraints_1.BandwidthConstraints(videobandwidth, audiobandwidth);\n    };\n    WebRTC.prototype.setMediaBitrates = function (sdp) {\n        return this.setMediaBitrate(this.setMediaBitrate(sdp, \"video\", this.bandwidthConstraints.videobandwidth), \"audio\", this.bandwidthConstraints.audiobandwidth);\n    };\n    WebRTC.prototype.setMediaBitrate = function (sdp, media, bitrate) {\n        var lines = sdp.split(\"\\n\");\n        var line = -1;\n        for (var i = 0; i < lines.length; i++) {\n            if (lines[i].indexOf(\"m=\" + media) === 0) {\n                line = i;\n                break;\n            }\n        }\n        if (line === -1) {\n            return sdp;\n        }\n        line++;\n        while (lines[line].indexOf(\"i=\") === 0 || lines[line].indexOf(\"c=\") === 0) {\n            line++;\n        }\n        if (lines[line].indexOf(\"b\") === 0) {\n            lines[line] = \"b=AS:\" + bitrate;\n            return lines.join(\"\\n\");\n        }\n        var newLines = lines.slice(0, line);\n        newLines.push(\"b=AS:\" + bitrate);\n        newLines = newLines.concat(lines.slice(line, lines.length));\n        return newLines.join(\"\\n\");\n    };\n    WebRTC.prototype.CreateDataChannel = function (name) {\n        var channel = new DataChannel_1.DataChannel(name);\n        this.DataChannels.set(name, channel);\n        return channel;\n    };\n    WebRTC.prototype.RemoveDataChannel = function (name) {\n        this.DataChannels.delete(name);\n    };\n    WebRTC.prototype.addError = function (err) {\n        this.OnError(err);\n    };\n    WebRTC.prototype.onCandidate = function (event) {\n        var _this = this;\n        var msg = JSON.parse(event.message);\n        var candidate = msg.iceCandidate;\n        var pc = this.getPeerConnection(event.sender);\n        pc.addIceCandidate(new RTCIceCandidate(candidate)).then(function () {\n        }).catch(function (err) {\n            _this.addError(err);\n        });\n    };\n    WebRTC.prototype.onAnswer = function (event) {\n        var _this = this;\n        var pc = this.getPeerConnection(event.sender);\n        pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(event.message))).then(function (p) {\n        }).catch(function (err) {\n            _this.addError(err);\n        });\n    };\n    WebRTC.prototype.onOffer = function (event) {\n        var _this = this;\n        var pc = this.getPeerConnection(event.sender);\n        this.LocalStreams.forEach(function (stream) {\n            stream.getTracks().forEach(function (track) {\n                pc.addTrack(track, stream);\n            });\n        });\n        pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(event.message)));\n        pc.createAnswer({ offerToReceiveAudio: true, offerToReceiveVideo: true }).then(function (description) {\n            pc.setLocalDescription(description).then(function () {\n                if (_this.bandwidthConstraints)\n                    description.sdp = _this.setMediaBitrates(description.sdp);\n                var answer = {\n                    sender: _this.LocalPeerId,\n                    recipient: event.sender,\n                    message: JSON.stringify(description)\n                };\n                _this.brokerController.Invoke(\"contextSignal\", answer);\n            }).catch(function (err) { return _this.addError(err); });\n        }).catch(function (err) { return _this.addError(err); });\n    };\n    WebRTC.prototype.AddLocalStream = function (stream) {\n        this.LocalStreams.push(stream);\n        return this;\n    };\n    WebRTC.prototype.AddIceServer = function (iceServer) {\n        this.rtcConfig.iceServers.push(iceServer);\n        return this;\n    };\n    WebRTC.prototype.removePeerConnection = function (id) {\n        this.Peers.delete(id);\n    };\n    WebRTC.prototype.createPeerConnection = function (id) {\n        var _this = this;\n        var rtcPeerConnection = new RTCPeerConnection(this.rtcConfig);\n        rtcPeerConnection.onsignalingstatechange = function (state) { };\n        rtcPeerConnection.onicecandidate = function (event) {\n            if (!event || !event.candidate)\n                return;\n            if (event.candidate) {\n                var msg = {\n                    sender: _this.LocalPeerId,\n                    recipient: id,\n                    message: JSON.stringify({\n                        type: 'candidate',\n                        iceCandidate: event.candidate\n                    })\n                };\n                _this.brokerController.Invoke(\"contextSignal\", msg);\n            }\n        };\n        rtcPeerConnection.oniceconnectionstatechange = function (event) {\n            switch (event.target.iceConnectionState) {\n                case \"connected\":\n                    _this.onConnected(id);\n                    break;\n                case \"disconnected\":\n                    _this.OnDisconnected(id);\n                    break;\n            }\n            ;\n        };\n        rtcPeerConnection.ontrack = function (event) {\n            var connection = _this.Peers.get(id);\n            connection.stream.addTrack(event.track);\n            _this.OnRemoteTrack(event.track, connection);\n        };\n        this.DataChannels.forEach(function (dataChannel) {\n            var pc = new PeerChannel_1.PeerChannel(id, rtcPeerConnection.createDataChannel(dataChannel.Name), dataChannel.Name);\n            dataChannel.addPeerChannel(pc);\n            rtcPeerConnection.ondatachannel = function (event) {\n                var channel = event.channel;\n                channel.onopen = function (event) {\n                    dataChannel.OnOpen(event, id);\n                };\n                channel.onclose = function (event) {\n                    dataChannel.removePeerChannel(id);\n                    dataChannel.OnClose(event, id);\n                };\n                channel.onmessage = function (message) {\n                    dataChannel.onMessage(message);\n                };\n            };\n        });\n        return rtcPeerConnection;\n    };\n    WebRTC.prototype.findPeerConnection = function (id) {\n        return this.Peers.get(id);\n    };\n    WebRTC.prototype.reconnectAll = function () {\n        throw \"not yet implemeted\";\n    };\n    WebRTC.prototype.getPeerConnection = function (id) {\n        var match = this.Peers.get(id);\n        if (!match) {\n            var pc = new WebRTCConnection_1.WebRTCConnection(id, this.createPeerConnection(id));\n            this.Peers.set(id, pc);\n            return pc.RTCPeer;\n        }\n        return match.RTCPeer;\n    };\n    WebRTC.prototype.createOffer = function (peer) {\n        var _this = this;\n        var peerConnection = this.createPeerConnection(peer.peerId);\n        this.LocalStreams.forEach(function (stream) {\n            stream.getTracks().forEach(function (track) {\n                peerConnection.addTrack(track, stream);\n            });\n            _this.OnLocalStream(stream);\n        });\n        peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true }).then(function (description) {\n            peerConnection.setLocalDescription(description).then(function () {\n                if (_this.bandwidthConstraints)\n                    description.sdp = _this.setMediaBitrates(description.sdp);\n                var offer = {\n                    sender: _this.LocalPeerId,\n                    recipient: peer.peerId,\n                    message: JSON.stringify(description)\n                };\n                _this.brokerController.Invoke(\"contextSignal\", offer);\n            }).catch(function (err) {\n                _this.addError(err);\n            });\n        }).catch(function (err) {\n            _this.addError(err);\n        });\n        return peerConnection;\n    };\n    WebRTC.prototype.Disconnect = function () {\n        this.Peers.forEach(function (connection) {\n            connection.RTCPeer.close();\n        });\n        this.ChangeContext(Math.random().toString(36).substring(2));\n    };\n    WebRTC.prototype.DisconnectPeer = function (id) {\n        var peer = this.findPeerConnection(id);\n        peer.RTCPeer.close();\n    };\n    WebRTC.prototype.Connect = function (peerConnections) {\n        var _this = this;\n        peerConnections.forEach(function (peerConnection) {\n            var pc = new WebRTCConnection_1.WebRTCConnection(peerConnection.peerId, _this.createOffer(peerConnection));\n            _this.Peers.set(peerConnection.peerId, pc);\n        });\n        return this;\n    };\n    WebRTC.prototype.ChangeContext = function (context) {\n        this.brokerController.Invoke(\"changeContext\", { context: context });\n        return this;\n    };\n    WebRTC.prototype.ConnectPeers = function () {\n        this.brokerController.Invoke(\"connectContext\", {});\n    };\n    WebRTC.prototype.ConnectContext = function () {\n        this.ConnectPeers();\n    };\n    return WebRTC;\n}());\nexports.WebRTC = WebRTC;\n\n\n//# sourceURL=webpack:///./node_modules/thor-io.client-vnext/src/WebRTC/WebRTC.js?");

/***/ }),

/***/ "./node_modules/thor-io.client-vnext/src/WebRTC/WebRTCConnection.js":
/*!**************************************************************************!*\
  !*** ./node_modules/thor-io.client-vnext/src/WebRTC/WebRTCConnection.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar WebRTCConnection = (function () {\n    function WebRTCConnection(id, rtcPeerConnection) {\n        this.id = id;\n        this.RTCPeer = rtcPeerConnection;\n        this.stream = new MediaStream();\n    }\n    return WebRTCConnection;\n}());\nexports.WebRTCConnection = WebRTCConnection;\n\n\n//# sourceURL=webpack:///./node_modules/thor-io.client-vnext/src/WebRTC/WebRTCConnection.js?");

/***/ })

/******/ });